<html>
<head>
  <title>adjacency matrix</title>
  <meta charset="utf-8" />
<script src="lib/d3.js" type="text/JavaScript"></script>
<script src="lib/colorbrewer.js" type="text/JavaScript"></script>
<script src="lib/queue.js" type="text/JavaScript"></script>
</head>
<style>
  svg {
    height: 300px;
    width: 300px;
    border: 1px solid gray;
  }

    .tick text {
        fill-opacity: 0;
    }

    .tickFoucus {
        fill-opacity: 1;
    }
</style>
<body>

<!-- <div id="viz">
  <svg>
  </svg>
</div> -->
<div id="controls" />
</body>
  <footer>

<script>
d3.csv('data/hongbao.csv', function(data) {
    var hongbao = {};
    var people = {};

    var senderSet = d3.set();

    data.forEach(function(d) {
        d.money_received = +d.money_received;
        if (d.money_received < 0) {
            if (!senderSet.has(d.people_name)) {
                senderSet.add(d.people_name);
            }
        }
    });



    // console.log(hongbao.senderCollection);

    dataNestedByPeople = d3.nest()
        .key(function(d) {
            return d.people_name;
        })
        .entries(data);

    dataNestedById = d3.nest()
        .key(function(d) {
            return d.hb_id;
        })
        .entries(data);
    // console.log(dataNestedById);
    drawMatrix('body', senderSet, dataNestedById, 400, 400);

    function drawMatrix(container, senderSet, dataNestedById, svgWidth, svgHeight) {
        hongbao.senderCollection = calculateSenderCollection(senderSet);

        var uniqEdges = calculateUniqEdges(dataNestedById);

        var matrix = calculateMatrix(hongbao.senderCollection, uniqEdges);

        setMatrix(container, matrix, hongbao.senderCollection, svgWidth, svgHeight);

        function calculateSenderCollection(senderSet) {
            var senderSetArray = senderSet.values();
            var senderCollection = senderSetArray.map(function(d) {
                return {people: d};
            });
            return senderCollection;
        }

        function calculateUniqEdges(dataNestedById) {
            var edgesDuplicate = dataNestedById.map(function(d) {
                var singleIdEdgeCollection = [];

                d.values.forEach(function(obj) {
                    var edge = {};
                    // console.log(obj.money_received);
                    if (obj.money_received > 0) {
                        // console.log(obj);
                        singleIdEdgeCollection.push({
                            source: d.values[0].people_name,
                            target: obj.people_name,
                            money: obj.money_received
                        });
                    }
                })
                return singleIdEdgeCollection;
            });

            // 连线：发送人-抢的人，以id为统计，64个统计结果数组
            var edgesConnectionDuplicate = edgesDuplicate.map(function(d) {
                var edgeHash = {};
                for (x in d) {
                    var id = d[x].source + "-" + d[x].target;
                    edgeHash[id] = d[x];
                    // console.log(id);
                }
                return edgeHash;
            });

            var mergedEdgesConnectionDuplicate = d3.merge([edgesConnectionDuplicate]);

            var uniqEdges = {};
            mergedEdgesConnectionDuplicate.forEach(function(d) {
                for(key in d) {
                    // console.log(key);
                    if (!uniqEdges[key]) {
                        uniqEdges[key] = d[key];
                    } else {
                        uniqEdges[key].money += d[key].money;
                    }
                }
            });

            return uniqEdges;
        }

        function calculateMatrix(hongbaoSenderCollection, uniqEdges) {
            var matrix = [];
            for (a in hongbaoSenderCollection) {
                for (b in hongbaoSenderCollection) {
                    var grid = {
                        id: hongbaoSenderCollection[a].people + "-" + hongbaoSenderCollection[b].people,
                        x: b,
                        y: a,
                        money: 0
                    }
                    // console.log(grid);

                    if (uniqEdges[grid.id]) {
                        grid.money = uniqEdges[grid.id].money;
                    }

                    matrix.push(grid);
                    // console.log(matrix);
                }
            }
            return matrix;
        }

        function setMatrix(container, matrix, hongbaoSenderCollection, svgWidth, svgHeight) {
            d3.select(container)
                .append("svg")
                .attr('width', svgWidth)
                .attr('height', svgHeight)
                .append("g")
                .attr("transform", "translate(50,50)")
                .attr("id", "adjacencyG")
                .selectAll("rect")
                .data(matrix)
                .enter()
                .append("rect")
                .attr("width", 10)
                .attr("height", 10)
                .attr("x", function (d) {return d.x * 10})
                .attr("y", function (d) {return d.y * 10})
                .style("stroke", "black")
                .style("stroke-width", "1px")
                .style("fill", "red")
                .style("fill-opacity", function (d) {return d.money * .2})
                .on("mouseover", gridOver)

            var scaleSize = hongbaoSenderCollection.length * 10;
            var nameScale = d3.scale.ordinal()
                .domain(hongbaoSenderCollection.map(function (el) {return el.people}))
                .rangePoints([0,scaleSize],1);

            xAxis = d3.svg.axis().scale(nameScale).orient("top").tickSize(4);
            yAxis = d3.svg.axis().scale(nameScale).orient("left").tickSize(4);

            d3.select("#adjacencyG")
                .append("g")
                .call(xAxis)
                // .selectAll("text")
                // .style("text-anchor", "end")
                // .attr("transform", "translate(-10,-10) rotate(90)");

            d3.select("#adjacencyG")
                .append("g")
                .call(yAxis);

            function gridOver(d,i) {
                d3.selectAll("rect")
                    .style("stroke-width", function (p) {
                        return p.x == d.x || p.y == d.y ? "3px" : "1px"
                    });
                // var selectedTick = 'tick:nth-child(' + i + ')';
                // console.log(d3.select(selectedTick));
                // d3.select(selectedTick).style('fill-opacity', 1);
            }
        }
    }



});

</script>
  </footer>

</html>
